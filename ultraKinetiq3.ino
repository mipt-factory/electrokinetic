#include <NewPing.h> // Подключаем бибилиотеку для работы с дальномером HC-SR04
#include <Servo.h> // Подключаем бибилиотеку для работы с сервоприводами
#define TRIGGER_PIN  11  // Номер разъёма на плате Arduino UNO для подключение trigger ультразвукового датчика HC-SR04
#define ECHO_PIN     12  // Номер разъёма на плате Arduino UNO для подключение echo ультразвукового датчика HC-SR04
#define MAX_DISTANCE 300 // Максимальная используемамя дальность измерений (в сантиметрах). Максимальная дальность измерения датчика 400-500 см.

NewPing sonar(TRIGGER_PIN, ECHO_PIN, MAX_DISTANCE); // Конструктор библиотеки NewPing, указываем разъёмы и дальность измерений
Servo myservo0;  // Создаём объект Servo для управления сервоприводом
Servo myservo1;  // Создаём объект Servo для управления сервоприводом

int val;    // Создаём переменную для хранения текущих значений измерений
int LED = LED_BUILTIN;   //  Светодиод на плате Arduino UNO
int mtime = 1500; // Длительность работы сервоприводов
int lastDistance = 0; // Последнее значение измерений
int thisDistance = 0; // Текщее значение измерений
unsigned int pingSpeed = 50; // Как часто производим измерения (в миллисекундах)
unsigned long pingTimer;     // Ожидание следующего временного промежутка


void setup () {
  Serial.begin(9600); // Задаём скорость обмена информацией с отладдочной платой Arduino UNO
  myservo0.attach(3);  // Присоединяем ранее созданный объект Servo к сервоприводу подключенному к разъёму 3 платы Arudino UNO
  delay(50);  // Временная задержка в 50 миллисекунд
  myservo1.attach(6);  // Присоединяем ранее созданный объект Servo к сервоприводу подключенному к разъёму 6 платы Arudino UNO
  delay(50);  // Временная задержка в 50 миллисекунд
  myservo1.write(90);  // Останавливаем сервопривод
  myservo0.write(90);  // Останавливаем сервопривод
  pingTimer = millis(); // Запускаем таймер
}
//
void loop () {
  if (millis() >= pingTimer) {   // pingSpeed milliseconds since last ping, do another ping.
    pingTimer += pingSpeed;      // Устанавливаем следующее время опроса датчика
    sonar.ping_timer(echoCheck); // Запуск процедуры опроса датчика вызываем функцию "echoCheck" (примерно каждые 24 мс), внутри которой мы получаем значение измерений
  }
  if (outCheck(lastDistance, thisDistance)) { // Вызываем функцию "outCheck" длч проверки ошибочных измерений
    Serial.println("-------------Same distance found: " + String(thisDistance) + " cm");  // При обнаружении ошибочных измерений расстояния, выводим сообщение в монитор отладки
  } else {
    Serial.println(String(thisDistance) + " cm");  // Если ошибочных измерений не обнаружено, переходим к продолжению выполнения программы
    if (thisDistance > 0) {  // Если текущее значение измерений дальности больше 0
      val = int(thisDistance);  // Устанавливаем значение переменной "val" равное текущему значению проведённых измерений преобразованному в целочисленное значение
      Serial.print(val);  // Выводим значение переменной "val"
      Serial.println(" cm");  // Указываем единицы измерения
      delay(250);  // Временная задержка в 250 миллисекунд
      if (val < 5) { // Выполняем следующий программный код при значении измерений более 5 см
        digitalWrite(LED, HIGH);  // Включаем встроенный светодиод
        myservo0.write(90);  // Останавливаем сервопривод
        myservo1.write(90);  // Останавливаем сервопривод
        Serial.print(val);  // Выводим значение измерений
        Serial.println(" cm stop");  // Добавляем к выводу единицы измерение и текущее предполагаемое состояние сервоприводов
        digitalWrite(LED, LOW);  // Выключаем встроенный светодиод
        delay(mtime * 3);  // Устанавливаем временную задержку
      }
      if (val < 50 && val > 5) { // Выполняем следующий программный код при значении измерений более 5 см и менее 50 см
        digitalWrite(LED, HIGH);  // Включаем встроенный светодиод
        myservo1.write(90);  // Останавливаем сервопривод
        myservo0.write(95);  // Включаем малый ход сервопривода
        delay(mtime * 2);  // Устанавливаем временную задержку
        myservo0.write(90);  // Останавливаем сервопривод
        myservo1.write(95);  // Включаем малый ход сервопривода
        Serial.print(val);  // Выводим значение измерений
        Serial.println(" cm. slow move");  // Добавляем к выводу единицы измерение и текущее предполагаемое состояние сервоприводов
        delay(mtime * 2);  // Устанавливаем временную задержку
        myservo0.write(90);  // Останавливаем сервопривод
        myservo1.write(90);  // Останавливаем сервопривод
        digitalWrite(LED, LOW);  // Выключаем встроенный светодиод
        delay(mtime);  // Устанавливаем временную задержку
      }
      if (val < 150 && val > 50) { // Выполняем следующий программный код при значении измерений более 50 см и менее 150 см
        digitalWrite(LED, HIGH);  // Включаем встроенный светодиод
        myservo0.write(90);  // Останавливаем сервопривод
        myservo1.write(100);  // Включаем быстрый ход сервопривода
        delay(mtime);  // Устанавливаем временную задержку
        myservo1.write(90);  // Останавливаем сервопривод
        myservo0.write(100);  // Включаем быстрый ход сервопривода
        Serial.print(val);  // Выводим значение измерений
        Serial.println(" cm. fast move");  // Добавляем к выводу единицы измерение и текущее предполагаемое состояние сервоприводов
        delay(mtime);  // Устанавливаем временную задержку
        myservo0.write(90);  // Останавливаем сервопривод
        myservo1.write(90);  // Останавливаем сервопривод
        digitalWrite(LED, LOW);  // Выключаем встроенный светодиод
        delay(mtime);  // Устанавливаем временную задержку
      }
      if (val < 220 && val > 150) { // Выполняем следующий программный код при значении измерений более 150 см и менее 220 см
        digitalWrite(LED, HIGH);  // Включаем встроенный светодиод
        myservo0.write(125);  // Включаем быстрый ход сервопривода
        myservo1.write(125);  // Включаем быстрый ход сервопривода
        Serial.print(val);  // Выводим значение измерений
        Serial.println(" cm. very fast move");  // Добавляем к выводу единицы измерение и текущее предполагаемое состояние сервоприводов
        delay(mtime);  // Устанавливаем временную задержку
        myservo0.write(90);  // Останавливаем сервопривод
        myservo1.write(90);  // Останавливаем сервопривод
        digitalWrite(LED, LOW);  // Выключаем встроенный светодиод
        delay(mtime);  // Устанавливаем временную задержку
      }
      if (val > 250) { // Выполняем следующий программный код при значении измерений более 250 см
        digitalWrite(LED, HIGH);  // Включаем встроенный светодиод
        myservo0.write(90);  // Останавливаем сервопривод
        myservo1.write(90);  // Останавливаем сервопривод
        Serial.print(val);  // Выводим значение измерений
        Serial.println(" cm stop");  // Добавляем к выводу единицы измерение и текущее предполагаемое состояние сервоприводов
        digitalWrite(LED, LOW);  // Выключаем встроенный светодиод
        delay(mtime * 3);  // Устанавливаем временную задержку
      }
    }
  }
}

void echoCheck() { // Функция получения измерений дальномером
  // Здесь ничего делать не нужно
  if (sonar.check_timer()) { // Проверям, получилось ли провести измерения расстояния
    Serial.print(sonar.ping_result / US_ROUNDTRIP_CM);  // Вызываем просудуру измерения и переподим получившееся значение в сантиметры. Выводим значение измерений
    Serial.println("cm"); // Добавляем к выводу единицы измерение
    delay(50);  // Устанавливаем временную задержку
    lastDistance = thisDistance;  // Сохраняем текущее значений измерений в переменную "lastDistance"
    thisDistance = sonar.ping_result / US_ROUNDTRIP_CM;  // Проводим новое измерение и сохраняем полученное значение в переменную "thisDistance"
  }
  // Здесь ничего делать не нужно
}

bool outCheck(int lastDistance, int thisDistance) {  //Функция определения ошибочных измерений

  // если текущее значение измерений больше предыдущего сразу на 20 см, подтверждаем ошибку измерений
  if ((lastDistance - thisDistance) > 20) {
    return true;
  } else {
    return false;
  }
}
